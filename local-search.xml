<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【设计模式】 工厂模式</title>
    <link href="/posts/b434.html"/>
    <url>/posts/b434.html</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式是一种创建型设计模式，它提供了一个创建对象的接口，而由子类来决定具体要创建哪个对象。它能够将客户端代码和具体的对象隔离开来，降低了代码的耦合度，同时也提高了代码的可扩展性和可维护性。 </p><h2 id="工厂模式的角色分配"><a href="#工厂模式的角色分配" class="headerlink" title="工厂模式的角色分配"></a>工厂模式的角色分配</h2><p>在工厂模式中，一般会涉及到以下几个角色： </p><ul><li>抽象工厂：这是一个抽象的工厂类，定义了创建对象的方法。 </li><li>具体工厂：这是一个具体的工厂类，实现了抽象工厂类，负责创建具体的对象。 </li><li>抽象产品：这是一个抽象的产品类，定义了产品的方法。 </li><li>具体产品：这是一个具体的产品类，实现了抽象产品类，提供产品的具体实现。</li></ul><h2 id="工厂模式的实现方式"><a href="#工厂模式的实现方式" class="headerlink" title="工厂模式的实现方式"></a>工厂模式的实现方式</h2><p>在 C++ 中，可以通过抽象类和虚函数来实现工厂模式。实现方式主要有以下两种： </p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式是工厂模式中最简单的一种实现方式，它只包含了一个具体工厂类和多个具体产品类。客户端通过传入不同的参数来请求具体的产品实例。这种实现方式简单易用，但扩展性较差。 </p><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品 A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductA</span> : <span class="hljs-keyword">public</span> Product &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ConcreteProductA operation&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品 B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductB</span> : <span class="hljs-keyword">public</span> Product &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ConcreteProductB operation&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 简单工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Product* <span class="hljs-title">createProduct</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (type) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProductA</span>();<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProductB</span>();<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 客户端调用</span><br>Product* productA = SimpleFactory::<span class="hljs-built_in">createProduct</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (productA != <span class="hljs-literal">nullptr</span>) &#123;<br>    productA-&gt;<span class="hljs-built_in">operation</span>();<br>&#125;<br><br>Product* productB = SimpleFactory::<span class="hljs-built_in">createProduct</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">if</span> (productB != <span class="hljs-literal">nullptr</span>) &#123;<br>    productB-&gt;<span class="hljs-built_in">operation</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式是工厂模式中经典的一种实现方式，它将具体产品的创建过程放到具体工厂类中完成。客户端只需要与抽象工厂接口交互，具体产品的创建过程被推迟到子类中进行。这种实现方式具有良好的扩展性和可维护性。 </p><h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品 A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductA</span> : <span class="hljs-keyword">public</span> Product &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ConcreteProductA operation&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品 B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductB</span> : <span class="hljs-keyword">public</span> Product &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ConcreteProductB operation&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 抽象工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Product* <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体工厂 A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactoryA</span> : <span class="hljs-keyword">public</span> Factory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Product* <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProductA</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体工厂 B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactoryB</span> : <span class="hljs-keyword">public</span> Factory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Product* <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProductB</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 客户端调用</span><br>Factory* factoryA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteFactoryA</span>();<br>Product* productA = factoryA-&gt;<span class="hljs-built_in">createProduct</span>();<br><span class="hljs-keyword">if</span> (productA != <span class="hljs-literal">nullptr</span>) &#123;<br>    productA-&gt;<span class="hljs-built_in">operation</span>();<br>&#125;<br><br>Factory* factoryB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteFactoryB</span>();<br>Product* productB = factoryB-&gt;<span class="hljs-built_in">createProduct</span>();<br><span class="hljs-keyword">if</span> (productB != <span class="hljs-literal">nullptr</span>) &#123;<br>    productB-&gt;<span class="hljs-built_in">operation</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a>工厂模式的优缺点</h2><p>工厂模式的优点主要包括： </p><ul><li>可以降低客户端代码和具体对象之间的耦合度。 </li><li>可以将具体对象的创建过程封装在具体工厂类中，提高了代码的可维护性和可扩展性。 </li><li>可以支持多态性。</li></ul><p>工厂模式的缺点主要包括： </p><ul><li>需要额外的工厂类，增加了代码的复杂度。 </li><li>简单工厂模式的扩展性较差。</li></ul><h2 id="工厂模式的应用场景"><a href="#工厂模式的应用场景" class="headerlink" title="工厂模式的应用场景"></a>工厂模式的应用场景</h2><p>在实际的开发中，工厂模式常常被应用在以下几个场景中： </p><ul><li>当客户端不知道具体实现类时，可以使用工厂模式创建对象。 </li><li>当需要创建的对象具有共同的接口时，可以使用工厂模式。 </li><li>当需要扩展或修改对象的创建过程时，可以使用工厂模式。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工厂模式是一种创建型设计模式，它能够降低客户端代码和具体对象之间的耦合度，提高了代码的可维护性和可扩展性。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渲染</title>
    <link href="/posts/Render.html"/>
    <url>/posts/Render.html</url>
    
    <content type="html"><![CDATA[<h1 id="前向渲染和延迟渲染"><a href="#前向渲染和延迟渲染" class="headerlink" title="前向渲染和延迟渲染"></a>前向渲染和延迟渲染</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在游戏开发中，渲染技术是一个非常重要的话题。而在现代游戏中，前向渲染和延迟渲染是两种非常常用的技术，它们各自有自己的特点和优势。本文将介绍前向渲染和延迟渲染的原理、优缺点以及应用场景。 </p><h2 id="2-前向渲染"><a href="#2-前向渲染" class="headerlink" title="2. 前向渲染"></a>2. 前向渲染</h2><p>前向渲染是最基础的渲染技术，它通过在每个像素上计算所有光源对该像素的影响来渲染场景。在每个像素上，先计算环境光照的影响，然后计算每个灯光的影响，最后加上镜面反射的贡献。这种渲染方式的好处是在处理透明度、深度、反射等方面非常方便，并且可以支持复杂的阴影计算和多个光源。然而由于每个像素都要进行光照计算，前向渲染的计算开销相对较高，而且会受到像素着色器并发执行的限制。因此，在需要渲染大量多光源或复杂场景的情况下，前向渲染通常需要牺牲一些画面质量或性能。 </p><h2 id="3-延迟渲染"><a href="#3-延迟渲染" class="headerlink" title="3. 延迟渲染"></a>3. 延迟渲染</h2><p>延迟渲染是近年来非常流行的渲染技术之一，它通过在屏幕空间中对所有像素进行几何体积和光照信息的缓存，并在后处理阶段使用这些缓存来渲染场景。这种渲染方式的好处在于它能够在光照计算上有很好的优化，多光源处理时只需要一次光照计算即可，可以有效地减少重复计算。同时，延迟渲染能够更好地支持Post-processing效果，并且能够提供大量的渲染数据，例如法线、深度、反射等信息，为后期的shader中的效果提供了良好的基础。 </p><p>然而，延迟渲染也有自己的缺点。因为它是在后处理阶段进行光照处理，所以它无法像前向渲染那样直接支持透明度，需要使用特殊的技术来处理。同时，对于一些较为复杂的场景，延迟渲染的开销也可能会很大。 </p><h2 id="4-前向渲染-vs-延迟渲染"><a href="#4-前向渲染-vs-延迟渲染" class="headerlink" title="4. 前向渲染 vs. 延迟渲染"></a>4. 前向渲染 vs. 延迟渲染</h2><p>前向渲染和延迟渲染各有自己的优缺点。在面对不同的场景和需求时，需要选择合适的渲染技术。 </p><p>前向渲染适用于需要渲染复杂场景、多光源、透明度等特殊效果的情况。同时，在高端硬件的支持下，前向渲染也可以提供比延迟渲染更好的画面效果和更流畅的游戏体验。 </p><p>延迟渲染适用于需要渲染大量的光源和物体的情况。同时，延迟渲染也能够为Post-processing效果提供更好的支持，并且可以提供充足的渲染数据，为shader的实现提供了基础。然而，对于那些具有较大复杂度的场景，延迟渲染的开销也可能会很高。 </p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>前向渲染和延迟渲染各有自己的特点和优势。在实际的游戏开发中，需要根据具体的需求和场景来选择合适的渲染技术。如果需要渲染复杂场景、多光源、透明度等特殊效果，可以选择前向渲染。如果需要渲染大量的光源和物体，可以选择延迟渲染。</p>]]></content>
    
    
    <categories>
      
      <category>UE4</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【设计模式】 单例模式</title>
    <link href="/posts/b434.html"/>
    <url>/posts/b434.html</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式是一种常用的设计模式，用于确保一个类只能有一个实例化对象。这种模式的优点在于可以节约系统资源、方便进行对象的管理和控制。 </p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>在单例模式中，类只有一个实例化对象，并且该对象可以通过一个全局操作方法进行访问。这个操作方法需要满足以下特点： </p><ul><li>该方法必须是静态的。 </li><li>该方法必须返回一个类的唯一实例对象。 </li><li>该方法必须保证只有一个实例对象被创建，并且该对象可以被多个客户端共享。</li></ul><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>在懒汉模式中，实例化对象的过程会被推迟到第一次访问该对象时。这种方式的优点是可以减少系统开销，但缺点是在多线程环境中可能会出现竞争条件，导致出现多个实例化对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* instance;<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br> Singleton* Singleton::instance = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们使用了静态成员变量和静态成员函数实现了单例模式，采用了懒汉式的实现方式。但是，上面的代码没有考虑线程安全的问题，解决方法有： </p><h4 id="1-在getInstance函数中加锁"><a href="#1-在getInstance函数中加锁" class="headerlink" title="1.在getInstance函数中加锁"></a>1.在getInstance函数中加锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* instance;<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> std::mutex mtx;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br> Singleton* Singleton::instance = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们在getInstance函数中使用了std::mutex来实现了线程同步，并保证了只有一个Singleton对象。 </p><h4 id="2-使用双重检查锁定-Double-Checked-Lock-方式"><a href="#2-使用双重检查锁定-Double-Checked-Lock-方式" class="headerlink" title="2.使用双重检查锁定(Double Checked Lock)方式"></a>2.使用双重检查锁定(Double Checked Lock)方式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-type">static</span> Singleton* instance;<br>     <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>     <span class="hljs-type">static</span> std::mutex mtx;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>) &#123;<br>             <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mtx)</span></span>;<br>             <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>) &#123;<br>                 instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">return</span> instance;<br>     &#125;<br>     ~<span class="hljs-built_in">Singleton</span>() &#123; <span class="hljs-keyword">delete</span> instance; &#125;<br>&#125;;<br>Singleton* Singleton::instance = <span class="hljs-literal">nullptr</span>;<br>std::mutex Singleton::mtx;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们使用std::mutex来实现了线程同步，并使用双重检查锁定方式避免了不必要的开销。每次获取Singleton对象时，第一次检查instance是否为空，如果为空则加锁，再次检查instance是否为空，如果为空则new一个Singleton对象。返回新创建的对象，并解锁。这种方式可以保证只有一个Singleton对象，并且是线程安全的。 </p><h4 id="3-静态局部变量实现懒汉模式"><a href="#3-静态局部变量实现懒汉模式" class="headerlink" title="3.静态局部变量实现懒汉模式"></a>3.静态局部变量实现懒汉模式</h4><p>还有一种方法是使用静态局部变量的方式来实现懒汉模式，它可以避免使用互斥锁的方式实现线程同步，比双重检查锁定方式更为高效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-type">static</span> Singleton instance;<br>         <span class="hljs-keyword">return</span> &amp;instance;<br>     &#125;<br>     ~<span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>     <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>     Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们使用了一个静态局部变量实现了懒汉模式，该静态局部变量仅在第一次调用getInstance()函数时才被初始化，并返回其地址，这样可以保证只有一个Singleton对象，并且不需要使用互斥量进行线程同步。 </p><p>需要注意的是，使用静态局部变量实现懒汉模式需要考虑线程安全问题，虽然该方法使用了静态局部变量，但是静态局部变量的初始化是线程不安全的，因此需要确保线程安全。</p><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>在饿汉模式中，实例化对象的过程是在程序运行时进行的，即在类的初始化阶段就已经完成了实例化对象的过程。这种方式的优点是可以避免竞争条件，但缺点是如果对象比较大，会导致系统资源浪费。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* instance;<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br> Singleton* Singleton::instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们使用了在类的初始化阶段完成静态成员变量的初始化实现了饿汉模式，不需要考虑线程安全问题。</p><p> 需要注意，以上的示例都是针对单线程或者多线程环境下不需要频繁创建和销毁单例对象的情况。如果需要频繁创建和销毁单例对象，可以考虑使用对象池等方式。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>单例模式通常在以下场景中使用： </p><ul><li>当需要确保只有一个对象实例并且该对象需要在多个地方进行访问时。 </li><li>当需要控制资源使用并避免过多的系统资源占用时。 </li><li>当需要使用全局变量时，可以将其实现为单例模式。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例模式是一种常用的设计模式，用于确保只有一个实例化对象的创建，并且该对象可以被多个客户端共享。在使用单例模式时需要注意保证线程安全和避免出现死锁等问题。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/1243066710.html"/>
    <url>/posts/1243066710.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
